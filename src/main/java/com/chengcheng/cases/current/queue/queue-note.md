### Java队列:
    - LinkedBlockingQueue:
        - 1. 基于链表的阻塞队列, 其底层的数据结构时链表;
        - 2. 链表维护先入先出队列, 新元素被放在对尾, 获取元素从对头部拿;
        - 3. 链表大小在初始化的时候可以设置, 默认是Integer的最大值;
        - 4. 可以使用Collection和Iterator两个接口的所有操作, 因为实现了两者的接口;
    - SynchronousQueue:
        - 1. 队列不存储数据, 所以没有大小, 也无法迭代;
        - 2. 插入操作的返回必须等待另一个线程完成对应数据的删除操作, 反之亦然;
        - 3. 队列由两种数据结构组成, 分别是后入先出的堆栈和先入先出的队列, 堆栈是非公平的,队列是公平的.
    - DelayQueue:
        - 1. 队列中元素将在过期时被执行, 越靠近队头, 越早过期;
        - 2. 未过期的元素不能够被take;
        - 3. 不允许空元素
    - ArrayBlockingQueue:
        - 1. 有界的阻塞数组, 容量一旦创建, 后续大小无法修改;
        - 2. 元素是有顺序的, 按照先入先出进行排序, 从队尾插入数据, 从队头拿数据;
        - 3. 队列满时, 往队列中put数据会被阻塞, 队列空时, 往队列中拿数据也会被阻塞;
### 问答:
    - LinkedBlockingQueue 和 ArrayBlockingQueue有啥区别?
        - 相同点:
            - 1. 两者的阻塞机制大体相同, 比如在队列满, 空时, 线程都会阻塞住.
        - 不同点:
            - 1. LinkedBlockingQueue 底层是链表结构, 容量默认是Intege的最大值,
                 ArrayBlockingQueue 底层是数组, 容量必须在初始化时指定.
            - 2. 两者的底层结构不同, 所以take,put,remove的底层实现也就不同.
    - 把数据放入队列种后, 有没有办法让队列过一会再执行?
        - 可以的, DealyQueue提供了这种机制, 可以设置一段时间之后再执行, 该队列有个唯一的缺点,
          就是数据保存在内存中, 在重启和断电的时候, 数据荣以丢失, 所以定时的时间我们都不会设置很久,
          一般都是几秒内, 如果定时的时间需要设置很久的话, 可以考虑采取延迟队列中间件(这种中间件对数据会进行持久化,
          ,不怕断电的发生) 进行实现.