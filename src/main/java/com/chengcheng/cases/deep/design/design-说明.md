1. 单例模式: 一个全局使用的类频繁地创建与销毁。
2. 工厂模式: 主要解决接口选择的问题。
3. 抽象工厂模式: 主要解决接口选择的问题。
4. 建造者模式: 主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
5. 原型模式: 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
6. 适配器模式: 主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
7. 桥接模式: 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
8. 组合模式: 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。
9. 装饰器模式: 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
10. 外观模式: 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
11. 亨元模式: 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
12. 代理模式: 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
13. 访问者模式: 稳定的数据结构和易变的操作耦合问题。
14. 模板模式: 一些方法通用，却在每一个子类都重新写了这一方法。
15. 策略模式: 在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
16. 状态模式: 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。
17. 观察者模式: 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
18. 备忘录模式: 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
19. 中介者模式: 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。
20. 迭代器模式: 不同的方式来遍历整个整合对象。
21. 解释器模式: 对于一些固定文法构建一个解释句子的解释器。
22. 命令模式: 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。
23. 责任链模式: 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

装饰器模式, 外观模式, 代理模式, 适配器模式, 工厂模式, 策略模式, 单例模式

设计模式遵循的六大原则:
1. 开闭原则:
    - 核心: 一个软件实体应当对拓展开放, 对修改关闭. 即: 软件实体应尽量在不修改原有代码的情况下进行拓展.
2. 里氏代换原则:
    - 核心: 所有引用父类的方法, 都必须能透明的使用其子类的对象.
3. 依赖倒转原则:
    - 核心: 抽象不应该依赖于细节, 细节应当依赖于抽象. 换言之, 要针对接口编程, 而非针对实现编程.
4. 单一职责原则:
    - 核心: 一个类只负责一个宫嗯那个领域中相应的职责, 或者可以定义为: 就一个类而言, 应该只有一个引起它变化的原因.
5. 接口隔离原则:
    - 核心: 使用多个专门的接口, 而不使用单一的总及接口. 即客户端不应该依赖于那些它不需要的接口.
6. 迪米特法则:
    - 核心: 一个软件实体应当尽可能少地与其他实体发生作用(无熟人难办事).
